/* 
 * Generated by gen_tokenizer.py. Do not edit by hand.
 * This file contains auto-generated token helper functions
 * 
 * Keywords: 53
 * Punctuators: 48
 * Total tokens: 101
 */

// Generated by gen_tokenizer.py. Do not edit by hand.
const char* token_to_string_gen(token_type t) {
  switch (t) {
    case TOKEN_AND: return "&";
    case TOKEN_AND_EQUAL: return "&=";
    case TOKEN_ARROW: return "->";
    case TOKEN_ASSIGN: return "=";
    case TOKEN_AT: return "@";
    case TOKEN_BRACE_CLOSE: return "}";
    case TOKEN_BRACE_OPEN: return "{";
    case TOKEN_BRACKET_CLOSE: return "]";
    case TOKEN_BRACKET_OPEN: return "[";
    case TOKEN_COLON: return ":";
    case TOKEN_COMMA: return ",";
    case TOKEN_DECREMENT: return "--";
    case TOKEN_DOT: return ".";
    case TOKEN_DOUBLE_AND: return "&&";
    case TOKEN_DOUBLE_HASH: return "##";
    case TOKEN_DOUBLE_OR: return "||";
    case TOKEN_EQUALITY: return "==";
    case TOKEN_EXCLAMATION: return "!";
    case TOKEN_GREATER: return ">";
    case TOKEN_GREATER_EQUAL: return ">=";
    case TOKEN_HASH: return "#";
    case TOKEN_INCREMENT: return "++";
    case TOKEN_KW_Alignas: return "_Alignas";
    case TOKEN_KW_Alignof: return "_Alignof";
    case TOKEN_KW_Atomic: return "_Atomic";
    case TOKEN_KW_Bool: return "_Bool";
    case TOKEN_KW_Complex: return "_Complex";
    case TOKEN_KW_Embed: return "_Embed";
    case TOKEN_KW_Generic: return "_Generic";
    case TOKEN_KW_Imaginary: return "_Imaginary";
    case TOKEN_KW_Noreturn: return "_Noreturn";
    case TOKEN_KW_Pragma: return "_Pragma";
    case TOKEN_KW_Static_assert: return "_Static_assert";
    case TOKEN_KW_Thread_local: return "_Thread_local";
    case TOKEN_KW_Typeof: return "_Typeof";
    case TOKEN_KW_Vector: return "_Vector";
    case TOKEN_KW_asm: return "asm";
    case TOKEN_KW_attribute: return "attribute";
    case TOKEN_KW_auto: return "auto";
    case TOKEN_KW_break: return "break";
    case TOKEN_KW_case: return "case";
    case TOKEN_KW_cdecl: return "cdecl";
    case TOKEN_KW_char: return "char";
    case TOKEN_KW_const: return "const";
    case TOKEN_KW_continue: return "continue";
    case TOKEN_KW_declspec: return "declspec";
    case TOKEN_KW_default: return "default";
    case TOKEN_KW_do: return "do";
    case TOKEN_KW_double: return "double";
    case TOKEN_KW_else: return "else";
    case TOKEN_KW_enum: return "enum";
    case TOKEN_KW_extern: return "extern";
    case TOKEN_KW_float: return "float";
    case TOKEN_KW_for: return "for";
    case TOKEN_KW_goto: return "goto";
    case TOKEN_KW_if: return "if";
    case TOKEN_KW_inline: return "inline";
    case TOKEN_KW_int: return "int";
    case TOKEN_KW_long: return "long";
    case TOKEN_KW_register: return "register";
    case TOKEN_KW_restrict: return "restrict";
    case TOKEN_KW_return: return "return";
    case TOKEN_KW_short: return "short";
    case TOKEN_KW_signed: return "signed";
    case TOKEN_KW_sizeof: return "sizeof";
    case TOKEN_KW_static: return "static";
    case TOKEN_KW_stdcall: return "stdcall";
    case TOKEN_KW_struct: return "struct";
    case TOKEN_KW_switch: return "switch";
    case TOKEN_KW_typedef: return "typedef";
    case TOKEN_KW_union: return "union";
    case TOKEN_KW_unsigned: return "unsigned";
    case TOKEN_KW_void: return "void";
    case TOKEN_KW_volatile: return "volatile";
    case TOKEN_KW_while: return "while";
    case TOKEN_LEFT_SHIFT: return "<<";
    case TOKEN_LEFT_SHIFT_EQUAL: return "<<=";
    case TOKEN_LESS: return "<";
    case TOKEN_LESS_EQUAL: return "<=";
    case TOKEN_MINUS: return "-";
    case TOKEN_MINUS_EQUAL: return "-=";
    case TOKEN_NOT_EQUAL: return "!=";
    case TOKEN_OR: return "|";
    case TOKEN_OR_EQUAL: return "|=";
    case TOKEN_PAREN_CLOSE: return ")";
    case TOKEN_PAREN_OPEN: return "(";
    case TOKEN_PERCENT: return "%";
    case TOKEN_PERCENT_EQUAL: return "%=";
    case TOKEN_PLUS: return "+";
    case TOKEN_PLUS_EQUAL: return "+=";
    case TOKEN_RIGHT_SHIFT: return ">>";
    case TOKEN_RIGHT_SHIFT_EQUAL: return ">>=";
    case TOKEN_SEMICOLON: return ";";
    case TOKEN_SLASH: return "/";
    case TOKEN_SLASH_EQUAL: return "/=";
    case TOKEN_TILDE: return "~";
    case TOKEN_TIMES: return "*";
    case TOKEN_TIMES_EQUAL: return "*=";
    case TOKEN_TRIPLE_DOT: return "...";
    case TOKEN_XOR: return "^";
    case TOKEN_XOR_EQUAL: return "^=";
    default: return "<unknown>";
  }
}

// Generated by gen_tokenizer.py. Do not edit by hand.
const char* token_type_to_string(token_type t) {
  switch (t) {
    case TOKEN_AND: return "TOKEN_AND";
    case TOKEN_AND_EQUAL: return "TOKEN_AND_EQUAL";
    case TOKEN_ARROW: return "TOKEN_ARROW";
    case TOKEN_ASSIGN: return "TOKEN_ASSIGN";
    case TOKEN_AT: return "TOKEN_AT";
    case TOKEN_BRACE_CLOSE: return "TOKEN_BRACE_CLOSE";
    case TOKEN_BRACE_OPEN: return "TOKEN_BRACE_OPEN";
    case TOKEN_BRACKET_CLOSE: return "TOKEN_BRACKET_CLOSE";
    case TOKEN_BRACKET_OPEN: return "TOKEN_BRACKET_OPEN";
    case TOKEN_COLON: return "TOKEN_COLON";
    case TOKEN_COMMA: return "TOKEN_COMMA";
    case TOKEN_COUNT: return "TOKEN_COUNT";
    case TOKEN_DECREMENT: return "TOKEN_DECREMENT";
    case TOKEN_DOT: return "TOKEN_DOT";
    case TOKEN_DOUBLE_AND: return "TOKEN_DOUBLE_AND";
    case TOKEN_DOUBLE_HASH: return "TOKEN_DOUBLE_HASH";
    case TOKEN_DOUBLE_OR: return "TOKEN_DOUBLE_OR";
    case TOKEN_EQUALITY: return "TOKEN_EQUALITY";
    case TOKEN_EXCLAMATION: return "TOKEN_EXCLAMATION";
    case TOKEN_FLOAT: return "TOKEN_FLOAT";
    case TOKEN_GREATER: return "TOKEN_GREATER";
    case TOKEN_GREATER_EQUAL: return "TOKEN_GREATER_EQUAL";
    case TOKEN_HASH: return "TOKEN_HASH";
    case TOKEN_IDENTIFIER: return "TOKEN_IDENTIFIER";
    case TOKEN_INCREMENT: return "TOKEN_INCREMENT";
    case TOKEN_INTEGER: return "TOKEN_INTEGER";
    case TOKEN_INVALID: return "TOKEN_INVALID";
    case TOKEN_KW_Alignas: return "TOKEN_KW_Alignas";
    case TOKEN_KW_Alignof: return "TOKEN_KW_Alignof";
    case TOKEN_KW_Atomic: return "TOKEN_KW_Atomic";
    case TOKEN_KW_Bool: return "TOKEN_KW_Bool";
    case TOKEN_KW_Complex: return "TOKEN_KW_Complex";
    case TOKEN_KW_Embed: return "TOKEN_KW_Embed";
    case TOKEN_KW_Generic: return "TOKEN_KW_Generic";
    case TOKEN_KW_Imaginary: return "TOKEN_KW_Imaginary";
    case TOKEN_KW_Noreturn: return "TOKEN_KW_Noreturn";
    case TOKEN_KW_Pragma: return "TOKEN_KW_Pragma";
    case TOKEN_KW_Static_assert: return "TOKEN_KW_Static_assert";
    case TOKEN_KW_Thread_local: return "TOKEN_KW_Thread_local";
    case TOKEN_KW_Typeof: return "TOKEN_KW_Typeof";
    case TOKEN_KW_Vector: return "TOKEN_KW_Vector";
    case TOKEN_KW_asm: return "TOKEN_KW_asm";
    case TOKEN_KW_attribute: return "TOKEN_KW_attribute";
    case TOKEN_KW_auto: return "TOKEN_KW_auto";
    case TOKEN_KW_break: return "TOKEN_KW_break";
    case TOKEN_KW_case: return "TOKEN_KW_case";
    case TOKEN_KW_cdecl: return "TOKEN_KW_cdecl";
    case TOKEN_KW_char: return "TOKEN_KW_char";
    case TOKEN_KW_const: return "TOKEN_KW_const";
    case TOKEN_KW_continue: return "TOKEN_KW_continue";
    case TOKEN_KW_declspec: return "TOKEN_KW_declspec";
    case TOKEN_KW_default: return "TOKEN_KW_default";
    case TOKEN_KW_do: return "TOKEN_KW_do";
    case TOKEN_KW_double: return "TOKEN_KW_double";
    case TOKEN_KW_else: return "TOKEN_KW_else";
    case TOKEN_KW_enum: return "TOKEN_KW_enum";
    case TOKEN_KW_extern: return "TOKEN_KW_extern";
    case TOKEN_KW_float: return "TOKEN_KW_float";
    case TOKEN_KW_for: return "TOKEN_KW_for";
    case TOKEN_KW_goto: return "TOKEN_KW_goto";
    case TOKEN_KW_if: return "TOKEN_KW_if";
    case TOKEN_KW_inline: return "TOKEN_KW_inline";
    case TOKEN_KW_int: return "TOKEN_KW_int";
    case TOKEN_KW_long: return "TOKEN_KW_long";
    case TOKEN_KW_register: return "TOKEN_KW_register";
    case TOKEN_KW_restrict: return "TOKEN_KW_restrict";
    case TOKEN_KW_return: return "TOKEN_KW_return";
    case TOKEN_KW_short: return "TOKEN_KW_short";
    case TOKEN_KW_signed: return "TOKEN_KW_signed";
    case TOKEN_KW_sizeof: return "TOKEN_KW_sizeof";
    case TOKEN_KW_static: return "TOKEN_KW_static";
    case TOKEN_KW_stdcall: return "TOKEN_KW_stdcall";
    case TOKEN_KW_struct: return "TOKEN_KW_struct";
    case TOKEN_KW_switch: return "TOKEN_KW_switch";
    case TOKEN_KW_typedef: return "TOKEN_KW_typedef";
    case TOKEN_KW_union: return "TOKEN_KW_union";
    case TOKEN_KW_unsigned: return "TOKEN_KW_unsigned";
    case TOKEN_KW_void: return "TOKEN_KW_void";
    case TOKEN_KW_volatile: return "TOKEN_KW_volatile";
    case TOKEN_KW_while: return "TOKEN_KW_while";
    case TOKEN_LEFT_SHIFT: return "TOKEN_LEFT_SHIFT";
    case TOKEN_LEFT_SHIFT_EQUAL: return "TOKEN_LEFT_SHIFT_EQUAL";
    case TOKEN_LESS: return "TOKEN_LESS";
    case TOKEN_LESS_EQUAL: return "TOKEN_LESS_EQUAL";
    case TOKEN_MINUS: return "TOKEN_MINUS";
    case TOKEN_MINUS_EQUAL: return "TOKEN_MINUS_EQUAL";
    case TOKEN_NEWLINE: return "TOKEN_NEWLINE";
    case TOKEN_NOT_EQUAL: return "TOKEN_NOT_EQUAL";
    case TOKEN_OR: return "TOKEN_OR";
    case TOKEN_OR_EQUAL: return "TOKEN_OR_EQUAL";
    case TOKEN_PAREN_CLOSE: return "TOKEN_PAREN_CLOSE";
    case TOKEN_PAREN_OPEN: return "TOKEN_PAREN_OPEN";
    case TOKEN_PERCENT: return "TOKEN_PERCENT";
    case TOKEN_PERCENT_EQUAL: return "TOKEN_PERCENT_EQUAL";
    case TOKEN_PLUS: return "TOKEN_PLUS";
    case TOKEN_PLUS_EQUAL: return "TOKEN_PLUS_EQUAL";
    case TOKEN_RIGHT_SHIFT: return "TOKEN_RIGHT_SHIFT";
    case TOKEN_RIGHT_SHIFT_EQUAL: return "TOKEN_RIGHT_SHIFT_EQUAL";
    case TOKEN_SEMICOLON: return "TOKEN_SEMICOLON";
    case TOKEN_SLASH: return "TOKEN_SLASH";
    case TOKEN_SLASH_EQUAL: return "TOKEN_SLASH_EQUAL";
    case TOKEN_STRING: return "TOKEN_STRING";
    case TOKEN_CHAR: return "TOKEN_CHAR";
    case TOKEN_WSTRING: return "TOKEN_WSTRING";
    case TOKEN_WCHAR: return "TOKEN_WCHAR";
    case TOKEN_TILDE: return "TOKEN_TILDE";
    case TOKEN_TIMES: return "TOKEN_TIMES";
    case TOKEN_TIMES_EQUAL: return "TOKEN_TIMES_EQUAL";
    case TOKEN_TRIPLE_DOT: return "TOKEN_TRIPLE_DOT";
    case TOKEN_XOR: return "TOKEN_XOR";
    case TOKEN_XOR_EQUAL: return "TOKEN_XOR_EQUAL";
    default: return "<unknown>";
  }
}

// Generated by gen_tokenizer.py. Do not edit by hand.
// Classify identifier tokens as keywords using optimized memcmp
token_type token_classify_identifier(const char* str, s64 length) {
  switch (length) {
    case 2:
      if (memcmp(str, "do", 2) == 0) return TOKEN_KW_do;
      if (memcmp(str, "if", 2) == 0) return TOKEN_KW_if;
      break;
    case 3:
      if (memcmp(str, "for", 3) == 0) return TOKEN_KW_for;
      if (memcmp(str, "int", 3) == 0) return TOKEN_KW_int;
      if (memcmp(str, "asm", 3) == 0) return TOKEN_KW_asm;
      break;
    case 4:
      if (memcmp(str, "auto", 4) == 0) return TOKEN_KW_auto;
      if (memcmp(str, "case", 4) == 0) return TOKEN_KW_case;
      if (memcmp(str, "char", 4) == 0) return TOKEN_KW_char;
      if (memcmp(str, "else", 4) == 0) return TOKEN_KW_else;
      if (memcmp(str, "enum", 4) == 0) return TOKEN_KW_enum;
      if (memcmp(str, "goto", 4) == 0) return TOKEN_KW_goto;
      if (memcmp(str, "long", 4) == 0) return TOKEN_KW_long;
      if (memcmp(str, "void", 4) == 0) return TOKEN_KW_void;
      break;
    case 5:
      if (memcmp(str, "break", 5) == 0) return TOKEN_KW_break;
      if (memcmp(str, "const", 5) == 0) return TOKEN_KW_const;
      if (memcmp(str, "float", 5) == 0) return TOKEN_KW_float;
      if (memcmp(str, "short", 5) == 0) return TOKEN_KW_short;
      if (memcmp(str, "union", 5) == 0) return TOKEN_KW_union;
      if (memcmp(str, "while", 5) == 0) return TOKEN_KW_while;
      if (memcmp(str, "_Bool", 5) == 0) return TOKEN_KW_Bool;
      if (memcmp(str, "cdecl", 5) == 0) return TOKEN_KW_cdecl;
      break;
    case 6:
      if (memcmp(str, "double", 6) == 0) return TOKEN_KW_double;
      if (memcmp(str, "extern", 6) == 0) return TOKEN_KW_extern;
      if (memcmp(str, "inline", 6) == 0) return TOKEN_KW_inline;
      if (memcmp(str, "return", 6) == 0) return TOKEN_KW_return;
      if (memcmp(str, "signed", 6) == 0) return TOKEN_KW_signed;
      if (memcmp(str, "sizeof", 6) == 0) return TOKEN_KW_sizeof;
      if (memcmp(str, "static", 6) == 0) return TOKEN_KW_static;
      if (memcmp(str, "struct", 6) == 0) return TOKEN_KW_struct;
      if (memcmp(str, "switch", 6) == 0) return TOKEN_KW_switch;
      if (memcmp(str, "_Embed", 6) == 0) return TOKEN_KW_Embed;
      break;
    case 7:
      if (memcmp(str, "default", 7) == 0) return TOKEN_KW_default;
      if (memcmp(str, "typedef", 7) == 0) return TOKEN_KW_typedef;
      if (memcmp(str, "_Atomic", 7) == 0) return TOKEN_KW_Atomic;
      if (memcmp(str, "_Pragma", 7) == 0) return TOKEN_KW_Pragma;
      if (memcmp(str, "_Typeof", 7) == 0) return TOKEN_KW_Typeof;
      if (memcmp(str, "_Vector", 7) == 0) return TOKEN_KW_Vector;
      if (memcmp(str, "stdcall", 7) == 0) return TOKEN_KW_stdcall;
      break;
    case 8:
      if (memcmp(str, "continue", 8) == 0) return TOKEN_KW_continue;
      if (memcmp(str, "register", 8) == 0) return TOKEN_KW_register;
      if (memcmp(str, "restrict", 8) == 0) return TOKEN_KW_restrict;
      if (memcmp(str, "unsigned", 8) == 0) return TOKEN_KW_unsigned;
      if (memcmp(str, "volatile", 8) == 0) return TOKEN_KW_volatile;
      if (memcmp(str, "_Alignas", 8) == 0) return TOKEN_KW_Alignas;
      if (memcmp(str, "_Alignof", 8) == 0) return TOKEN_KW_Alignof;
      if (memcmp(str, "_Complex", 8) == 0) return TOKEN_KW_Complex;
      if (memcmp(str, "_Generic", 8) == 0) return TOKEN_KW_Generic;
      if (memcmp(str, "declspec", 8) == 0) return TOKEN_KW_declspec;
      break;
    case 9:
      if (memcmp(str, "_Noreturn", 9) == 0) return TOKEN_KW_Noreturn;
      if (memcmp(str, "attribute", 9) == 0) return TOKEN_KW_attribute;
      break;
    case 10:
      if (memcmp(str, "_Imaginary", 10) == 0) return TOKEN_KW_Imaginary;
      break;
    case 13:
      if (memcmp(str, "_Thread_local", 13) == 0) return TOKEN_KW_Thread_local;
      break;
    case 14:
      if (memcmp(str, "_Static_assert", 14) == 0) return TOKEN_KW_Static_assert;
      break;
    default: break;
  }
  return TOKEN_IDENTIFIER;
}

// Generated by gen_tokenizer.py. Do not edit by hand.
// Threaded jump table for character-by-character matching
// Assumes null-terminated string with 16 null bytes padding at end
// Keywords are handled separately by token_classify_identifier
// Takes advantage of token_type encoding where ASCII chars map directly to their values
// Uses u32 comparisons for multi-character operators
token token_switch(tokenizer ref tz) {
  const char* s = tz.Current;
  if (!s[0]) return {TOKEN_INVALID, s - tz.Start };

  static const void* jump_table[256] = {
    [0x00] = &&label_default,
    [0x01] = &&label_default,
    [0x02] = &&label_default,
    [0x03] = &&label_default,
    [0x04] = &&label_default,
    [0x05] = &&label_default,
    [0x06] = &&label_default,
    [0x07] = &&label_default,
    [0x08] = &&label_default,
    [0x09] = &&label_default,
    [0x0A] = &&label_default,
    [0x0B] = &&label_default,
    [0x0C] = &&label_default,
    [0x0D] = &&label_default,
    [0x0E] = &&label_default,
    [0x0F] = &&label_default,
    [0x10] = &&label_default,
    [0x11] = &&label_default,
    [0x12] = &&label_default,
    [0x13] = &&label_default,
    [0x14] = &&label_default,
    [0x15] = &&label_default,
    [0x16] = &&label_default,
    [0x17] = &&label_default,
    [0x18] = &&label_default,
    [0x19] = &&label_default,
    [0x1A] = &&label_default,
    [0x1B] = &&label_default,
    [0x1C] = &&label_default,
    [0x1D] = &&label_default,
    [0x1E] = &&label_default,
    [0x1F] = &&label_default,
    [0x20] = &&label_default,
    [0x21] = &&label_21, // '!' (multi-char)
    [0x22] = &&label_default,
    [0x23] = &&label_23, // '#' (multi-char)
    [0x24] = &&label_default,
    [0x25] = &&label_25, // '%' (multi-char)
    [0x26] = &&label_26, // '&' (multi-char)
    [0x27] = &&label_default,
    [0x28] = &&label_single_char, // '('
    [0x29] = &&label_single_char, // ')'
    [0x2A] = &&label_2A, // '*' (multi-char)
    [0x2B] = &&label_2B, // '+' (multi-char)
    [0x2C] = &&label_single_char, // ','
    [0x2D] = &&label_2D, // '-' (multi-char)
    [0x2E] = &&label_2E, // '.' (multi-char)
    [0x2F] = &&label_2F, // '/' (multi-char)
    [0x30] = &&label_number, // '0'
    [0x31] = &&label_number, // '1'
    [0x32] = &&label_number, // '2'
    [0x33] = &&label_number, // '3'
    [0x34] = &&label_number, // '4'
    [0x35] = &&label_number, // '5'
    [0x36] = &&label_number, // '6'
    [0x37] = &&label_number, // '7'
    [0x38] = &&label_number, // '8'
    [0x39] = &&label_number, // '9'
    [0x3A] = &&label_single_char, // ':'
    [0x3B] = &&label_single_char, // ';'
    [0x3C] = &&label_3C, // '<' (multi-char)
    [0x3D] = &&label_3D, // '=' (multi-char)
    [0x3E] = &&label_3E, // '>' (multi-char)
    [0x3F] = &&label_default,
    [0x40] = &&label_single_char, // '@'
    [0x41] = &&label_ident, // 'A'
    [0x42] = &&label_ident, // 'B'
    [0x43] = &&label_ident, // 'C'
    [0x44] = &&label_ident, // 'D'
    [0x45] = &&label_ident, // 'E'
    [0x46] = &&label_ident, // 'F'
    [0x47] = &&label_ident, // 'G'
    [0x48] = &&label_ident, // 'H'
    [0x49] = &&label_ident, // 'I'
    [0x4A] = &&label_ident, // 'J'
    [0x4B] = &&label_ident, // 'K'
    [0x4C] = &&label_ident, // 'L'
    [0x4D] = &&label_ident, // 'M'
    [0x4E] = &&label_ident, // 'N'
    [0x4F] = &&label_ident, // 'O'
    [0x50] = &&label_ident, // 'P'
    [0x51] = &&label_ident, // 'Q'
    [0x52] = &&label_ident, // 'R'
    [0x53] = &&label_ident, // 'S'
    [0x54] = &&label_ident, // 'T'
    [0x55] = &&label_ident, // 'U'
    [0x56] = &&label_ident, // 'V'
    [0x57] = &&label_ident, // 'W'
    [0x58] = &&label_ident, // 'X'
    [0x59] = &&label_ident, // 'Y'
    [0x5A] = &&label_ident, // 'Z'
    [0x5B] = &&label_single_char, // '['
    [0x5C] = &&label_default,
    [0x5D] = &&label_single_char, // ']'
    [0x5E] = &&label_5E, // '^' (multi-char)
    [0x5F] = &&label_ident, // '_'
    [0x60] = &&label_default,
    [0x61] = &&label_ident, // 'a'
    [0x62] = &&label_ident, // 'b'
    [0x63] = &&label_ident, // 'c'
    [0x64] = &&label_ident, // 'd'
    [0x65] = &&label_ident, // 'e'
    [0x66] = &&label_ident, // 'f'
    [0x67] = &&label_ident, // 'g'
    [0x68] = &&label_ident, // 'h'
    [0x69] = &&label_ident, // 'i'
    [0x6A] = &&label_ident, // 'j'
    [0x6B] = &&label_ident, // 'k'
    [0x6C] = &&label_ident, // 'l'
    [0x6D] = &&label_ident, // 'm'
    [0x6E] = &&label_ident, // 'n'
    [0x6F] = &&label_ident, // 'o'
    [0x70] = &&label_ident, // 'p'
    [0x71] = &&label_ident, // 'q'
    [0x72] = &&label_ident, // 'r'
    [0x73] = &&label_ident, // 's'
    [0x74] = &&label_ident, // 't'
    [0x75] = &&label_ident, // 'u'
    [0x76] = &&label_ident, // 'v'
    [0x77] = &&label_ident, // 'w'
    [0x78] = &&label_ident, // 'x'
    [0x79] = &&label_ident, // 'y'
    [0x7A] = &&label_ident, // 'z'
    [0x7B] = &&label_single_char, // '{'
    [0x7C] = &&label_7C, // '|' (multi-char)
    [0x7D] = &&label_single_char, // '}'
    [0x7E] = &&label_single_char, // '~'
    [0x7F] = &&label_default,
    [0x80] = &&label_default,
    [0x81] = &&label_default,
    [0x82] = &&label_default,
    [0x83] = &&label_default,
    [0x84] = &&label_default,
    [0x85] = &&label_default,
    [0x86] = &&label_default,
    [0x87] = &&label_default,
    [0x88] = &&label_default,
    [0x89] = &&label_default,
    [0x8A] = &&label_default,
    [0x8B] = &&label_default,
    [0x8C] = &&label_default,
    [0x8D] = &&label_default,
    [0x8E] = &&label_default,
    [0x8F] = &&label_default,
    [0x90] = &&label_default,
    [0x91] = &&label_default,
    [0x92] = &&label_default,
    [0x93] = &&label_default,
    [0x94] = &&label_default,
    [0x95] = &&label_default,
    [0x96] = &&label_default,
    [0x97] = &&label_default,
    [0x98] = &&label_default,
    [0x99] = &&label_default,
    [0x9A] = &&label_default,
    [0x9B] = &&label_default,
    [0x9C] = &&label_default,
    [0x9D] = &&label_default,
    [0x9E] = &&label_default,
    [0x9F] = &&label_default,
    [0xA0] = &&label_default,
    [0xA1] = &&label_default,
    [0xA2] = &&label_default,
    [0xA3] = &&label_default,
    [0xA4] = &&label_default,
    [0xA5] = &&label_default,
    [0xA6] = &&label_default,
    [0xA7] = &&label_default,
    [0xA8] = &&label_default,
    [0xA9] = &&label_default,
    [0xAA] = &&label_default,
    [0xAB] = &&label_default,
    [0xAC] = &&label_default,
    [0xAD] = &&label_default,
    [0xAE] = &&label_default,
    [0xAF] = &&label_default,
    [0xB0] = &&label_default,
    [0xB1] = &&label_default,
    [0xB2] = &&label_default,
    [0xB3] = &&label_default,
    [0xB4] = &&label_default,
    [0xB5] = &&label_default,
    [0xB6] = &&label_default,
    [0xB7] = &&label_default,
    [0xB8] = &&label_default,
    [0xB9] = &&label_default,
    [0xBA] = &&label_default,
    [0xBB] = &&label_default,
    [0xBC] = &&label_default,
    [0xBD] = &&label_default,
    [0xBE] = &&label_default,
    [0xBF] = &&label_default,
    [0xC0] = &&label_default,
    [0xC1] = &&label_default,
    [0xC2] = &&label_default,
    [0xC3] = &&label_default,
    [0xC4] = &&label_default,
    [0xC5] = &&label_default,
    [0xC6] = &&label_default,
    [0xC7] = &&label_default,
    [0xC8] = &&label_default,
    [0xC9] = &&label_default,
    [0xCA] = &&label_default,
    [0xCB] = &&label_default,
    [0xCC] = &&label_default,
    [0xCD] = &&label_default,
    [0xCE] = &&label_default,
    [0xCF] = &&label_default,
    [0xD0] = &&label_default,
    [0xD1] = &&label_default,
    [0xD2] = &&label_default,
    [0xD3] = &&label_default,
    [0xD4] = &&label_default,
    [0xD5] = &&label_default,
    [0xD6] = &&label_default,
    [0xD7] = &&label_default,
    [0xD8] = &&label_default,
    [0xD9] = &&label_default,
    [0xDA] = &&label_default,
    [0xDB] = &&label_default,
    [0xDC] = &&label_default,
    [0xDD] = &&label_default,
    [0xDE] = &&label_default,
    [0xDF] = &&label_default,
    [0xE0] = &&label_default,
    [0xE1] = &&label_default,
    [0xE2] = &&label_default,
    [0xE3] = &&label_default,
    [0xE4] = &&label_default,
    [0xE5] = &&label_default,
    [0xE6] = &&label_default,
    [0xE7] = &&label_default,
    [0xE8] = &&label_default,
    [0xE9] = &&label_default,
    [0xEA] = &&label_default,
    [0xEB] = &&label_default,
    [0xEC] = &&label_default,
    [0xED] = &&label_default,
    [0xEE] = &&label_default,
    [0xEF] = &&label_default,
    [0xF0] = &&label_default,
    [0xF1] = &&label_default,
    [0xF2] = &&label_default,
    [0xF3] = &&label_default,
    [0xF4] = &&label_default,
    [0xF5] = &&label_default,
    [0xF6] = &&label_default,
    [0xF7] = &&label_default,
    [0xF8] = &&label_default,
    [0xF9] = &&label_default,
    [0xFA] = &&label_default,
    [0xFB] = &&label_default,
    [0xFC] = &&label_default,
    [0xFD] = &&label_default,
    [0xFE] = &&label_default,
    [0xFF] = &&label_default,
  };

  goto *jump_table[(unsigned char)s[0]];

label_21: // '!' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_NOT_EQUAL, s - tz.Start }; } // "!="
  }
  // Fall through to single character: !
  tz.Current += 1;
  return { (token_type)'!', s - tz.Start };

label_23: // '#' multi-character
  {
    if (s[1] == 0x23) { tz.Current += 2; return { TOKEN_DOUBLE_HASH, s - tz.Start }; } // "##"
  }
  // Fall through to single character: #
  tz.Current += 1;
  return { (token_type)'#', s - tz.Start };

label_25: // '%' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_PERCENT_EQUAL, s - tz.Start }; } // "%="
  }
  // Fall through to single character: %
  tz.Current += 1;
  return { (token_type)'%', s - tz.Start };

label_26: // '&' multi-character
  {
    if (s[1] == 0x26) { tz.Current += 2; return { TOKEN_DOUBLE_AND, s - tz.Start }; } // "&&"
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_AND_EQUAL, s - tz.Start }; } // "&="
  }
  // Fall through to single character: &
  tz.Current += 1;
  return { (token_type)'&', s - tz.Start };

label_2A: // '*' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_TIMES_EQUAL, s - tz.Start }; } // "*="
  }
  // Fall through to single character: *
  tz.Current += 1;
  return { (token_type)'*', s - tz.Start };

label_2B: // '+' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_PLUS_EQUAL, s - tz.Start }; } // "+="
    if (s[1] == 0x2B) { tz.Current += 2; return { TOKEN_INCREMENT, s - tz.Start }; } // "++"
  }
  // Fall through to single character: +
  // Special case: +123 should be parsed as signed number, not + + INTEGER
  if (ascii_is_digit(s[1])) return tokenizer_next_number_literal(tz);
  tz.Current += 1;
  return { (token_type)'+', s - tz.Start };

label_2D: // '-' multi-character
  {
    if (s[1] == 0x3E) { tz.Current += 2; return { TOKEN_ARROW, s - tz.Start }; } // "->"
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_MINUS_EQUAL, s - tz.Start }; } // "-="
    if (s[1] == 0x2D) { tz.Current += 2; return { TOKEN_DECREMENT, s - tz.Start }; } // "--"
  }
  // Fall through to single character: -
  // Special case: -123 should be parsed as signed number, not - + INTEGER
  if (ascii_is_digit(s[1])) return tokenizer_next_number_literal(tz);
  tz.Current += 1;
  return { (token_type)'-', s - tz.Start };

label_2E: // '.' multi-character
  {
    if (s[1] == 0x2E && s[2] == 0x2E) { tz.Current += 3; return { TOKEN_TRIPLE_DOT, s - tz.Start }; } // "..."
  }
  // Fall through to single character: .
  // Special case: .123 should be parsed as float, not DOT + INTEGER
  if (ascii_is_digit(s[1])) return tokenizer_next_number_literal(tz);
  tz.Current += 1;
  return { (token_type)'.', s - tz.Start };

label_2F: // '/' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_SLASH_EQUAL, s - tz.Start }; } // "/="
  }
  // Fall through to single character: /
  tz.Current += 1;
  return { (token_type)'/', s - tz.Start };

label_3C: // '<' multi-character
  {
    if (s[1] == 0x3C && s[2] == 0x3D) { tz.Current += 3; return { TOKEN_LEFT_SHIFT_EQUAL, s - tz.Start }; } // "<<="
  }
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_LESS_EQUAL, s - tz.Start }; } // "<="
    if (s[1] == 0x3C) { tz.Current += 2; return { TOKEN_LEFT_SHIFT, s - tz.Start }; } // "<<"
  }
  // Fall through to single character: <
  tz.Current += 1;
  return { (token_type)'<', s - tz.Start };

label_3D: // '=' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_EQUALITY, s - tz.Start }; } // "=="
  }
  // Fall through to single character: =
  tz.Current += 1;
  return { (token_type)'=', s - tz.Start };

label_3E: // '>' multi-character
  {
    if (s[1] == 0x3E && s[2] == 0x3D) { tz.Current += 3; return { TOKEN_RIGHT_SHIFT_EQUAL, s - tz.Start }; } // ">>="
  }
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_GREATER_EQUAL, s - tz.Start }; } // ">="
    if (s[1] == 0x3E) { tz.Current += 2; return { TOKEN_RIGHT_SHIFT, s - tz.Start }; } // ">>"
  }
  // Fall through to single character: >
  tz.Current += 1;
  return { (token_type)'>', s - tz.Start };

label_5E: // '^' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_XOR_EQUAL, s - tz.Start }; } // "^="
  }
  // Fall through to single character: ^
  tz.Current += 1;
  return { (token_type)'^', s - tz.Start };

label_7C: // '|' multi-character
  {
    if (s[1] == 0x7C) { tz.Current += 2; return { TOKEN_DOUBLE_OR, s - tz.Start }; } // "||"
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_OR_EQUAL, s - tz.Start }; } // "|="
  }
  // Fall through to single character: |
  tz.Current += 1;
  return { (token_type)'|', s - tz.Start };

label_single_char:
  // Single character punctuator - token type is the ASCII value
  tz.Current += 1;
  return { (token_type)s[0], s - tz.Start };

label_number:
  // Handle number literals using separate parse_number function
  return tokenizer_next_number_literal(tz);

label_ident:
  // Handle ASCII identifier characters
  do {
    s++;
  } while (ascii_is_identifier_cont(*s));
  tz.Current = s;
  return { TOKEN_IDENTIFIER, s - tz.Start };

label_default:
  // Non-ASCII or invalid character
  return { TOKEN_INVALID, s - tz.Start };
}