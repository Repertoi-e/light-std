/* 
 * Generated by gen_tokenizer.py. Do not edit by hand.
 * This file contains auto-generated token helper functions
 * 
 * Keywords: 12
 * Punctuators: 49
 * Total tokens: 61
 */

// Generated by gen_tokenizer.py. Do not edit by hand.
const char* token_to_string_gen(token_type t) {
  switch (t) {
    case TOKEN_AND: return "&";
    case TOKEN_AND_EQUAL: return "&=";
    case TOKEN_ARROW: return "=>";
    case TOKEN_ASTERISK: return "*";
    case TOKEN_ASTERISK_EQUAL: return "*=";
    case TOKEN_AT: return "@";
    case TOKEN_BAR: return "|";
    case TOKEN_BAR_EQUAL: return "|=";
    case TOKEN_BRACE_CLOSE: return "}";
    case TOKEN_BRACE_OPEN: return "{";
    case TOKEN_BRACKET_CLOSE: return "]";
    case TOKEN_BRACKET_OPEN: return "[";
    case TOKEN_COLON: return ":";
    case TOKEN_COMMA: return ",";
    case TOKEN_DECREMENT: return "--";
    case TOKEN_DOT: return ".";
    case TOKEN_DOUBLE_AND: return "&&";
    case TOKEN_DOUBLE_BAR: return "||";
    case TOKEN_DOUBLE_DOT: return "..";
    case TOKEN_EQUAL: return "=";
    case TOKEN_EQUAL_EQUAL: return "==";
    case TOKEN_EXCLAMATION: return "!";
    case TOKEN_GREATER: return ">";
    case TOKEN_GREATER_EQUAL: return ">=";
    case TOKEN_HASH: return "#";
    case TOKEN_HAT: return "^";
    case TOKEN_HAT_EQUAL: return "^=";
    case TOKEN_INCREMENT: return "++";
    case TOKEN_KW_break: return "break";
    case TOKEN_KW_char: return "char";
    case TOKEN_KW_continue: return "continue";
    case TOKEN_KW_do: return "do";
    case TOKEN_KW_else: return "else";
    case TOKEN_KW_for: return "for";
    case TOKEN_KW_if: return "if";
    case TOKEN_KW_pass: return "pass";
    case TOKEN_KW_return: return "return";
    case TOKEN_KW_struct: return "struct";
    case TOKEN_KW_void: return "void";
    case TOKEN_KW_while: return "while";
    case TOKEN_LEFT_SHIFT: return "<<";
    case TOKEN_LEFT_SHIFT_EQUAL: return "<<=";
    case TOKEN_LESS: return "<";
    case TOKEN_LESS_EQUAL: return "<=";
    case TOKEN_MINUS: return "-";
    case TOKEN_MINUS_EQUAL: return "-=";
    case TOKEN_NOT_EQUAL: return "!=";
    case TOKEN_PAREN_CLOSE: return ")";
    case TOKEN_PAREN_OPEN: return "(";
    case TOKEN_PERCENT: return "%";
    case TOKEN_PERCENT_EQUAL: return "%=";
    case TOKEN_PLUS: return "+";
    case TOKEN_PLUS_EQUAL: return "+=";
    case TOKEN_QUESTION: return "?";
    case TOKEN_RIGHT_SHIFT: return ">>";
    case TOKEN_RIGHT_SHIFT_EQUAL: return ">>=";
    case TOKEN_SEMICOLON: return ";";
    case TOKEN_SLASH: return "/";
    case TOKEN_SLASH_EQUAL: return "/=";
    case TOKEN_TILDE: return "~";
    case TOKEN_TRIPLE_DOT: return "...";
    default: return "<unknown>";
  }
}

// Generated by gen_tokenizer.py. Do not edit by hand.
const char* token_type_to_string(token_type t) {
  switch (t) {
    case TOKEN_AND: return "TOKEN_AND";
    case TOKEN_AND_EQUAL: return "TOKEN_AND_EQUAL";
    case TOKEN_ARROW: return "TOKEN_ARROW";
    case TOKEN_ASTERISK: return "TOKEN_ASTERISK";
    case TOKEN_ASTERISK_EQUAL: return "TOKEN_ASTERISK_EQUAL";
    case TOKEN_AT: return "TOKEN_AT";
    case TOKEN_BAR: return "TOKEN_BAR";
    case TOKEN_BAR_EQUAL: return "TOKEN_BAR_EQUAL";
    case TOKEN_BRACE_CLOSE: return "TOKEN_BRACE_CLOSE";
    case TOKEN_BRACE_OPEN: return "TOKEN_BRACE_OPEN";
    case TOKEN_BRACKET_CLOSE: return "TOKEN_BRACKET_CLOSE";
    case TOKEN_BRACKET_OPEN: return "TOKEN_BRACKET_OPEN";
    case TOKEN_COLON: return "TOKEN_COLON";
    case TOKEN_COMMA: return "TOKEN_COMMA";
    case TOKEN_COUNT: return "TOKEN_COUNT";
    case TOKEN_DECREMENT: return "TOKEN_DECREMENT";
    case TOKEN_DOT: return "TOKEN_DOT";
    case TOKEN_DOUBLE_AND: return "TOKEN_DOUBLE_AND";
    case TOKEN_DOUBLE_BAR: return "TOKEN_DOUBLE_BAR";
    case TOKEN_DOUBLE_DOT: return "TOKEN_DOUBLE_DOT";
    case TOKEN_EQUAL: return "TOKEN_EQUAL";
    case TOKEN_EQUAL_EQUAL: return "TOKEN_EQUAL_EQUAL";
    case TOKEN_EXCLAMATION: return "TOKEN_EXCLAMATION";
    case TOKEN_FLOAT: return "TOKEN_FLOAT";
    case TOKEN_GREATER: return "TOKEN_GREATER";
    case TOKEN_GREATER_EQUAL: return "TOKEN_GREATER_EQUAL";
    case TOKEN_HASH: return "TOKEN_HASH";
    case TOKEN_HAT: return "TOKEN_HAT";
    case TOKEN_HAT_EQUAL: return "TOKEN_HAT_EQUAL";
    case TOKEN_IDENTIFIER: return "TOKEN_IDENTIFIER";
    case TOKEN_INCREMENT: return "TOKEN_INCREMENT";
    case TOKEN_INTEGER: return "TOKEN_INTEGER";
    case TOKEN_INVALID: return "TOKEN_INVALID";
    case TOKEN_KW_break: return "TOKEN_KW_break";
    case TOKEN_KW_char: return "TOKEN_KW_char";
    case TOKEN_KW_continue: return "TOKEN_KW_continue";
    case TOKEN_KW_do: return "TOKEN_KW_do";
    case TOKEN_KW_else: return "TOKEN_KW_else";
    case TOKEN_KW_for: return "TOKEN_KW_for";
    case TOKEN_KW_if: return "TOKEN_KW_if";
    case TOKEN_KW_pass: return "TOKEN_KW_pass";
    case TOKEN_KW_return: return "TOKEN_KW_return";
    case TOKEN_KW_struct: return "TOKEN_KW_struct";
    case TOKEN_KW_void: return "TOKEN_KW_void";
    case TOKEN_KW_while: return "TOKEN_KW_while";
    case TOKEN_LEFT_SHIFT: return "TOKEN_LEFT_SHIFT";
    case TOKEN_LEFT_SHIFT_EQUAL: return "TOKEN_LEFT_SHIFT_EQUAL";
    case TOKEN_LESS: return "TOKEN_LESS";
    case TOKEN_LESS_EQUAL: return "TOKEN_LESS_EQUAL";
    case TOKEN_MINUS: return "TOKEN_MINUS";
    case TOKEN_MINUS_EQUAL: return "TOKEN_MINUS_EQUAL";
    case TOKEN_NEWLINE: return "TOKEN_NEWLINE";
    case TOKEN_NOT_EQUAL: return "TOKEN_NOT_EQUAL";
    case TOKEN_PAREN_CLOSE: return "TOKEN_PAREN_CLOSE";
    case TOKEN_PAREN_OPEN: return "TOKEN_PAREN_OPEN";
    case TOKEN_PERCENT: return "TOKEN_PERCENT";
    case TOKEN_PERCENT_EQUAL: return "TOKEN_PERCENT_EQUAL";
    case TOKEN_PLUS: return "TOKEN_PLUS";
    case TOKEN_PLUS_EQUAL: return "TOKEN_PLUS_EQUAL";
    case TOKEN_POISONED: return "TOKEN_POISONED";
    case TOKEN_QUESTION: return "TOKEN_QUESTION";
    case TOKEN_RIGHT_SHIFT: return "TOKEN_RIGHT_SHIFT";
    case TOKEN_RIGHT_SHIFT_EQUAL: return "TOKEN_RIGHT_SHIFT_EQUAL";
    case TOKEN_SEMICOLON: return "TOKEN_SEMICOLON";
    case TOKEN_SLASH: return "TOKEN_SLASH";
    case TOKEN_SLASH_EQUAL: return "TOKEN_SLASH_EQUAL";
    case TOKEN_STRING: return "TOKEN_STRING";
    case TOKEN_TILDE: return "TOKEN_TILDE";
    case TOKEN_TRIPLE_DOT: return "TOKEN_TRIPLE_DOT";
    case TOKEN_UNICODE_PUNCTUATION: return "TOKEN_UNICODE_PUNCTUATION";
    default: return "<unknown>";
  }
}

// Generated by gen_tokenizer.py. Do not edit by hand.
// Classify identifier tokens as keywords using optimized memcmp
token_type token_classify_identifier(const char* str, s64 length) {
  switch (length) {
    case 2:
      if (memcmp(str, "do", 2) == 0) return TOKEN_KW_do;
      if (memcmp(str, "if", 2) == 0) return TOKEN_KW_if;
      break;
    case 3:
      if (memcmp(str, "for", 3) == 0) return TOKEN_KW_for;
      break;
    case 4:
      if (memcmp(str, "char", 4) == 0) return TOKEN_KW_char;
      if (memcmp(str, "pass", 4) == 0) return TOKEN_KW_pass;
      if (memcmp(str, "else", 4) == 0) return TOKEN_KW_else;
      if (memcmp(str, "void", 4) == 0) return TOKEN_KW_void;
      break;
    case 5:
      if (memcmp(str, "break", 5) == 0) return TOKEN_KW_break;
      if (memcmp(str, "while", 5) == 0) return TOKEN_KW_while;
      break;
    case 6:
      if (memcmp(str, "return", 6) == 0) return TOKEN_KW_return;
      if (memcmp(str, "struct", 6) == 0) return TOKEN_KW_struct;
      break;
    case 8:
      if (memcmp(str, "continue", 8) == 0) return TOKEN_KW_continue;
      break;
    default: break;
  }
  return TOKEN_IDENTIFIER;
}


// Generated by gen_tokenizer.py. Do not edit by hand.
// Threaded jump table for character-by-character matching
// Assumes null-terminated string with 16 null bytes padding at end
// Keywords are handled separately by token_classify_identifier
// Takes advantage of token_type encoding where ASCII chars map directly to their values
// Uses u32 comparisons for multi-character operators
token token_switch(tokenizer ref tz) {
  const char* s = tz.Current;
  if (!s[0]) return {TOKEN_INVALID, s - tz.Start };

  static const void* jump_table[256] = {
    [0x00] = &&label_default,
    [0x01] = &&label_default,
    [0x02] = &&label_default,
    [0x03] = &&label_default,
    [0x04] = &&label_default,
    [0x05] = &&label_default,
    [0x06] = &&label_default,
    [0x07] = &&label_default,
    [0x08] = &&label_default,
    [0x09] = &&label_default,
    [0x0A] = &&label_default,
    [0x0B] = &&label_default,
    [0x0C] = &&label_default,
    [0x0D] = &&label_default,
    [0x0E] = &&label_default,
    [0x0F] = &&label_default,
    [0x10] = &&label_default,
    [0x11] = &&label_default,
    [0x12] = &&label_default,
    [0x13] = &&label_default,
    [0x14] = &&label_default,
    [0x15] = &&label_default,
    [0x16] = &&label_default,
    [0x17] = &&label_default,
    [0x18] = &&label_default,
    [0x19] = &&label_default,
    [0x1A] = &&label_default,
    [0x1B] = &&label_default,
    [0x1C] = &&label_default,
    [0x1D] = &&label_default,
    [0x1E] = &&label_default,
    [0x1F] = &&label_default,
    [0x20] = &&label_default,
    [0x21] = &&label_21, // '!' (multi-char)
    [0x22] = &&label_default,
    [0x23] = &&label_single_char, // '#'
    [0x24] = &&label_default,
    [0x25] = &&label_25, // '%' (multi-char)
    [0x26] = &&label_26, // '&' (multi-char)
    [0x27] = &&label_default,
    [0x28] = &&label_single_char, // '('
    [0x29] = &&label_single_char, // ')'
    [0x2A] = &&label_2A, // '*' (multi-char)
    [0x2B] = &&label_2B, // '+' (multi-char)
    [0x2C] = &&label_single_char, // ','
    [0x2D] = &&label_2D, // '-' (multi-char)
    [0x2E] = &&label_2E, // '.' (multi-char)
    [0x2F] = &&label_2F, // '/' (multi-char)
    [0x30] = &&label_number, // '0'
    [0x31] = &&label_number, // '1'
    [0x32] = &&label_number, // '2'
    [0x33] = &&label_number, // '3'
    [0x34] = &&label_number, // '4'
    [0x35] = &&label_number, // '5'
    [0x36] = &&label_number, // '6'
    [0x37] = &&label_number, // '7'
    [0x38] = &&label_number, // '8'
    [0x39] = &&label_number, // '9'
    [0x3A] = &&label_single_char, // ':'
    [0x3B] = &&label_single_char, // ';'
    [0x3C] = &&label_3C, // '<' (multi-char)
    [0x3D] = &&label_3D, // '=' (multi-char)
    [0x3E] = &&label_3E, // '>' (multi-char)
    [0x3F] = &&label_single_char, // '?'
    [0x40] = &&label_single_char, // '@'
    [0x41] = &&label_ident, // 'A'
    [0x42] = &&label_ident, // 'B'
    [0x43] = &&label_ident, // 'C'
    [0x44] = &&label_ident, // 'D'
    [0x45] = &&label_ident, // 'E'
    [0x46] = &&label_ident, // 'F'
    [0x47] = &&label_ident, // 'G'
    [0x48] = &&label_ident, // 'H'
    [0x49] = &&label_ident, // 'I'
    [0x4A] = &&label_ident, // 'J'
    [0x4B] = &&label_ident, // 'K'
    [0x4C] = &&label_ident, // 'L'
    [0x4D] = &&label_ident, // 'M'
    [0x4E] = &&label_ident, // 'N'
    [0x4F] = &&label_ident, // 'O'
    [0x50] = &&label_ident, // 'P'
    [0x51] = &&label_ident, // 'Q'
    [0x52] = &&label_ident, // 'R'
    [0x53] = &&label_ident, // 'S'
    [0x54] = &&label_ident, // 'T'
    [0x55] = &&label_ident, // 'U'
    [0x56] = &&label_ident, // 'V'
    [0x57] = &&label_ident, // 'W'
    [0x58] = &&label_ident, // 'X'
    [0x59] = &&label_ident, // 'Y'
    [0x5A] = &&label_ident, // 'Z'
    [0x5B] = &&label_single_char, // '['
    [0x5C] = &&label_default,
    [0x5D] = &&label_single_char, // ']'
    [0x5E] = &&label_5E, // '^' (multi-char)
    [0x5F] = &&label_ident, // '_'
    [0x60] = &&label_default,
    [0x61] = &&label_ident, // 'a'
    [0x62] = &&label_ident, // 'b'
    [0x63] = &&label_ident, // 'c'
    [0x64] = &&label_ident, // 'd'
    [0x65] = &&label_ident, // 'e'
    [0x66] = &&label_ident, // 'f'
    [0x67] = &&label_ident, // 'g'
    [0x68] = &&label_ident, // 'h'
    [0x69] = &&label_ident, // 'i'
    [0x6A] = &&label_ident, // 'j'
    [0x6B] = &&label_ident, // 'k'
    [0x6C] = &&label_ident, // 'l'
    [0x6D] = &&label_ident, // 'm'
    [0x6E] = &&label_ident, // 'n'
    [0x6F] = &&label_ident, // 'o'
    [0x70] = &&label_ident, // 'p'
    [0x71] = &&label_ident, // 'q'
    [0x72] = &&label_ident, // 'r'
    [0x73] = &&label_ident, // 's'
    [0x74] = &&label_ident, // 't'
    [0x75] = &&label_ident, // 'u'
    [0x76] = &&label_ident, // 'v'
    [0x77] = &&label_ident, // 'w'
    [0x78] = &&label_ident, // 'x'
    [0x79] = &&label_ident, // 'y'
    [0x7A] = &&label_ident, // 'z'
    [0x7B] = &&label_single_char, // '{'
    [0x7C] = &&label_7C, // '|' (multi-char)
    [0x7D] = &&label_single_char, // '}'
    [0x7E] = &&label_single_char, // '~'
    [0x7F] = &&label_default,
    [0x80] = &&label_default,
    [0x81] = &&label_default,
    [0x82] = &&label_default,
    [0x83] = &&label_default,
    [0x84] = &&label_default,
    [0x85] = &&label_default,
    [0x86] = &&label_default,
    [0x87] = &&label_default,
    [0x88] = &&label_default,
    [0x89] = &&label_default,
    [0x8A] = &&label_default,
    [0x8B] = &&label_default,
    [0x8C] = &&label_default,
    [0x8D] = &&label_default,
    [0x8E] = &&label_default,
    [0x8F] = &&label_default,
    [0x90] = &&label_default,
    [0x91] = &&label_default,
    [0x92] = &&label_default,
    [0x93] = &&label_default,
    [0x94] = &&label_default,
    [0x95] = &&label_default,
    [0x96] = &&label_default,
    [0x97] = &&label_default,
    [0x98] = &&label_default,
    [0x99] = &&label_default,
    [0x9A] = &&label_default,
    [0x9B] = &&label_default,
    [0x9C] = &&label_default,
    [0x9D] = &&label_default,
    [0x9E] = &&label_default,
    [0x9F] = &&label_default,
    [0xA0] = &&label_default,
    [0xA1] = &&label_default,
    [0xA2] = &&label_default,
    [0xA3] = &&label_default,
    [0xA4] = &&label_default,
    [0xA5] = &&label_default,
    [0xA6] = &&label_default,
    [0xA7] = &&label_default,
    [0xA8] = &&label_default,
    [0xA9] = &&label_default,
    [0xAA] = &&label_default,
    [0xAB] = &&label_default,
    [0xAC] = &&label_default,
    [0xAD] = &&label_default,
    [0xAE] = &&label_default,
    [0xAF] = &&label_default,
    [0xB0] = &&label_default,
    [0xB1] = &&label_default,
    [0xB2] = &&label_default,
    [0xB3] = &&label_default,
    [0xB4] = &&label_default,
    [0xB5] = &&label_default,
    [0xB6] = &&label_default,
    [0xB7] = &&label_default,
    [0xB8] = &&label_default,
    [0xB9] = &&label_default,
    [0xBA] = &&label_default,
    [0xBB] = &&label_default,
    [0xBC] = &&label_default,
    [0xBD] = &&label_default,
    [0xBE] = &&label_default,
    [0xBF] = &&label_default,
    [0xC0] = &&label_default,
    [0xC1] = &&label_default,
    [0xC2] = &&label_default,
    [0xC3] = &&label_default,
    [0xC4] = &&label_default,
    [0xC5] = &&label_default,
    [0xC6] = &&label_default,
    [0xC7] = &&label_default,
    [0xC8] = &&label_default,
    [0xC9] = &&label_default,
    [0xCA] = &&label_default,
    [0xCB] = &&label_default,
    [0xCC] = &&label_default,
    [0xCD] = &&label_default,
    [0xCE] = &&label_default,
    [0xCF] = &&label_default,
    [0xD0] = &&label_default,
    [0xD1] = &&label_default,
    [0xD2] = &&label_default,
    [0xD3] = &&label_default,
    [0xD4] = &&label_default,
    [0xD5] = &&label_default,
    [0xD6] = &&label_default,
    [0xD7] = &&label_default,
    [0xD8] = &&label_default,
    [0xD9] = &&label_default,
    [0xDA] = &&label_default,
    [0xDB] = &&label_default,
    [0xDC] = &&label_default,
    [0xDD] = &&label_default,
    [0xDE] = &&label_default,
    [0xDF] = &&label_default,
    [0xE0] = &&label_default,
    [0xE1] = &&label_default,
    [0xE2] = &&label_default,
    [0xE3] = &&label_default,
    [0xE4] = &&label_default,
    [0xE5] = &&label_default,
    [0xE6] = &&label_default,
    [0xE7] = &&label_default,
    [0xE8] = &&label_default,
    [0xE9] = &&label_default,
    [0xEA] = &&label_default,
    [0xEB] = &&label_default,
    [0xEC] = &&label_default,
    [0xED] = &&label_default,
    [0xEE] = &&label_default,
    [0xEF] = &&label_default,
    [0xF0] = &&label_default,
    [0xF1] = &&label_default,
    [0xF2] = &&label_default,
    [0xF3] = &&label_default,
    [0xF4] = &&label_default,
    [0xF5] = &&label_default,
    [0xF6] = &&label_default,
    [0xF7] = &&label_default,
    [0xF8] = &&label_default,
    [0xF9] = &&label_default,
    [0xFA] = &&label_default,
    [0xFB] = &&label_default,
    [0xFC] = &&label_default,
    [0xFD] = &&label_default,
    [0xFE] = &&label_default,
    [0xFF] = &&label_default,
  };

  goto *jump_table[(unsigned char)s[0]];

label_21: // '!' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_NOT_EQUAL, s - tz.Start }; } // "!="
  }
  // Fall through to single character: !
  tz.Current += 1;
  return { (token_type)'!', s - tz.Start };

label_25: // '%' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_PERCENT_EQUAL, s - tz.Start }; } // "%="
  }
  // Fall through to single character: %
  tz.Current += 1;
  return { (token_type)'%', s - tz.Start };

label_26: // '&' multi-character
  {
    if (s[1] == 0x26) { tz.Current += 2; return { TOKEN_DOUBLE_AND, s - tz.Start }; } // "&&"
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_AND_EQUAL, s - tz.Start }; } // "&="
  }
  // Fall through to single character: &
  tz.Current += 1;
  return { (token_type)'&', s - tz.Start };

label_2A: // '*' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_ASTERISK_EQUAL, s - tz.Start }; } // "*="
  }
  // Fall through to single character: *
  tz.Current += 1;
  return { (token_type)'*', s - tz.Start };

label_2B: // '+' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_PLUS_EQUAL, s - tz.Start }; } // "+="
    if (s[1] == 0x2B) { tz.Current += 2; return { TOKEN_INCREMENT, s - tz.Start }; } // "++"
  }
  // Fall through to single character: +
  // Special case: +123 should be parsed as signed number, not + + INTEGER
  if (ascii_is_digit(s[1])) return tokenizer_next_number_literal(tz);
  tz.Current += 1;
  return { (token_type)'+', s - tz.Start };

label_2D: // '-' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_MINUS_EQUAL, s - tz.Start }; } // "-="
    if (s[1] == 0x2D) { tz.Current += 2; return { TOKEN_DECREMENT, s - tz.Start }; } // "--"
  }
  // Fall through to single character: -
  // Special case: -123 should be parsed as signed number, not - + INTEGER
  if (ascii_is_digit(s[1])) return tokenizer_next_number_literal(tz);
  tz.Current += 1;
  return { (token_type)'-', s - tz.Start };

label_2E: // '.' multi-character
  {
    if (s[1] == 0x2E && s[2] == 0x2E) { tz.Current += 3; return { TOKEN_TRIPLE_DOT, s - tz.Start }; } // "..."
  }
  {
    if (s[1] == 0x2E) { tz.Current += 2; return { TOKEN_DOUBLE_DOT, s - tz.Start }; } // ".."
  }
  // Fall through to single character: .
  // Special case: .123 should be parsed as float, not DOT + INTEGER
  if (ascii_is_digit(s[1])) return tokenizer_next_number_literal(tz);
  tz.Current += 1;
  return { (token_type)'.', s - tz.Start };

label_2F: // '/' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_SLASH_EQUAL, s - tz.Start }; } // "/="
  }
  // Fall through to single character: /
  tz.Current += 1;
  return { (token_type)'/', s - tz.Start };

label_3C: // '<' multi-character
  {
    if (s[1] == 0x3C && s[2] == 0x3D) { tz.Current += 3; return { TOKEN_LEFT_SHIFT_EQUAL, s - tz.Start }; } // "<<="
  }
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_LESS_EQUAL, s - tz.Start }; } // "<="
    if (s[1] == 0x3C) { tz.Current += 2; return { TOKEN_LEFT_SHIFT, s - tz.Start }; } // "<<"
  }
  // Fall through to single character: <
  tz.Current += 1;
  return { (token_type)'<', s - tz.Start };

label_3D: // '=' multi-character
  {
    if (s[1] == 0x3E) { tz.Current += 2; return { TOKEN_ARROW, s - tz.Start }; } // "=>"
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_EQUAL_EQUAL, s - tz.Start }; } // "=="
  }
  // Fall through to single character: =
  tz.Current += 1;
  return { (token_type)'=', s - tz.Start };

label_3E: // '>' multi-character
  {
    if (s[1] == 0x3E && s[2] == 0x3D) { tz.Current += 3; return { TOKEN_RIGHT_SHIFT_EQUAL, s - tz.Start }; } // ">>="
  }
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_GREATER_EQUAL, s - tz.Start }; } // ">="
    if (s[1] == 0x3E) { tz.Current += 2; return { TOKEN_RIGHT_SHIFT, s - tz.Start }; } // ">>"
  }
  // Fall through to single character: >
  tz.Current += 1;
  return { (token_type)'>', s - tz.Start };

label_5E: // '^' multi-character
  {
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_HAT_EQUAL, s - tz.Start }; } // "^="
  }
  // Fall through to single character: ^
  tz.Current += 1;
  return { (token_type)'^', s - tz.Start };

label_7C: // '|' multi-character
  {
    if (s[1] == 0x7C) { tz.Current += 2; return { TOKEN_DOUBLE_BAR, s - tz.Start }; } // "||"
    if (s[1] == 0x3D) { tz.Current += 2; return { TOKEN_BAR_EQUAL, s - tz.Start }; } // "|="
  }
  // Fall through to single character: |
  tz.Current += 1;
  return { (token_type)'|', s - tz.Start };

label_single_char:
  // Single character punctuator - token type is the ASCII value
  tz.Current += 1;
  return { (token_type)s[0], s - tz.Start };

label_number:
  // Handle number literals using separate parse_number function
  return tokenizer_next_number_literal(tz);

label_ident:
  // Handle ASCII identifier characters
  do {
    s++;
  } while (ascii_is_identifier_cont(*s));
  tz.Current = s;
  return { TOKEN_IDENTIFIER, s - tz.Start };

label_default:
  // Non-ASCII or invalid character
  return { TOKEN_INVALID, s - tz.Start };
}